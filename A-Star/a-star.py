#!/usr/bin/env python3

'''
    Author: Stiven LaVrenov
    Program: a-star.py
    Description: Given an initial board state from random-board.py, use an A* search algorithm to find the most optimal solution with 1 of 4
                 different heuristics, as well as determine several different statistics for algorithmic analysis. 
                 Heuristics: 0, Displaced Tiles, Manhattan Distance, & a novel heuristic (Chebyshev Distance in this example)
    Complete Usage: cat [standard input file] | ./random-board.py [seed] [random # of moves] | ./a-star.py [heuristic]
    Sole Usage: ./a-star.py [heuristic]
'''

import sys, heapq, copy

# Check for proper command line arguments
if len(sys.argv) != 2:
    print('\n', 'Usage: %s [heuristic to use]' %(sys.argv[0]), '\n')
    sys.exit(1)

# Set Class to act as a closed list
class Set():
    def __init__(self):
        self.thisSet = set()
    def add(self,entry):
        if entry is not None:
            self.thisSet.add(entry.__hash__())
    def length(self):
        return len(self.thisSet)
    def isMember(self,query):
        return query.__hash__() in self.thisSet

# state Class to keep track of puzzle states
class state():
    def __init__(self, puzzle):
        self.xpos = 0
        self.ypos = 0
        # self.tiles = [[0,1,2],[3,4,5],[6,7,8]]
        self.tiles = puzzle
    def left(self):
        if (self.ypos == 0):
            return None
        s = self.copy()
        s.tiles[s.xpos][s.ypos] = s.tiles[s.xpos][s.ypos-1]
        s.ypos -= 1
        s.tiles[s.xpos][s.ypos] = 0
        return s
    def right(self):
        if (self.ypos == 2):
            return None
        s = self.copy()
        s.tiles[s.xpos][s.ypos] = s.tiles[s.xpos][s.ypos+1]
        s.ypos += 1
        s.tiles[s.xpos][s.ypos] = 0
        return s
    def up(self):
        if (self.xpos == 0):
            return None
        s = self.copy()
        s.tiles[s.xpos][s.ypos] = s.tiles[s.xpos-1][s.ypos]
        s.xpos -= 1
        s.tiles[s.xpos][s.ypos] = 0
        return s
    def down(self):
        if (self.xpos == 2):
            return None
        s = self.copy()
        s.tiles[s.xpos][s.ypos] = s.tiles[s.xpos+1][s.ypos]
        s.xpos += 1
        s.tiles[s.xpos][s.ypos] = 0
        return s
    def __hash__(self):
        return (tuple(self.tiles[0]),tuple(self.tiles[1]),tuple(self.tiles[2]))
    def __str__(self):
        return '%d %d %d\n%d %d %d\n%d %d %d\n'%(
                self.tiles[0][0],self.tiles[0][1],self.tiles[0][2],
                self.tiles[1][0],self.tiles[1][1],self.tiles[1][2],
                self.tiles[2][0],self.tiles[2][1],self.tiles[2][2])
    def displaced(self, goal):
        count = 0
        for x in range(3):
            for y in range(3):
                if self.tiles[x][y] != goal[x][y]:
                    count += 1
        return count
    def manhattan_dist(self, goal):
        dist = 0
        for x in range(3):
            for y in range(3):
                a = abs(self.tiles[x][y] // 3 - goal[x][y] // 3)
                b = abs(self.tiles[x][y] % 3 - goal[x][y] % 3)
                dist += a + b
        return dist
    def chebyshev_dist(self, goal):
        dist = 0
        for x in range(3):
            for y in range(3):
                a = abs(self.tiles[x][y] // 3 - goal[x][y] // 3)
                b = abs(self.tiles[x][y] % 3 - goal[x][y] % 3)
                dist += max(a, b)
        return dist
    def copy(self):
        s = copy.deepcopy(self)
        return s

# PriorityQueue Class to prioritize nodes in descending order
class PriorityQueue():
    def __init__(self):
        self.thisQueue = []
    def push(self, thisNode):
        heapq.heappush(self.thisQueue, (thisNode.val, -thisNode.id, thisNode))
    def pop(self):
        return heapq.heappop(self.thisQueue)[2]
    def isEmpty(self):
        return len(self.thisQueue) == 0
    def length(self):
        return len(self.thisQueue)

# node Class to expand the search tree with states
nodeid = 0
class node():
    def __init__(self,val,state,parent):
        global nodeid
        self.id = nodeid
        nodeid += 1
        self.val = val
        self.state = state
        self.parent = parent
    def __str__(self):
        return 'Node: id=%d val=%d'%(self.id,self.val)

# Iterate through the initial state given by random-board.py, and re-assign new x and y positions
def fix_coords(s, fixed, puzzle):
    for row in puzzle:
        if not fixed:
            s.ypos = 0
            for num in row:
                if num == 0:
                    fixed = True
                    break
                s.ypos += 1
            if not fixed:
                s.xpos += 1
    return s.xpos, s.ypos

# A* Search Algorithm
def a_star(puzzle, goal, heuristic):
    # Initialize states for initial puzzle generated by random-board.py and the necessary goal state
    s = state(puzzle)
    goal_state = state(goal)

    # 'Reposition' the state x and y coordinates for the new puzzle
    fixed = False
    s.xpos, s.ypos = fix_coords(s, fixed, puzzle)

    # CLOSED LIST(S)
    closed_list = Set()
    puzzle_set = Set()

    # PRIORITY QUEUE
    frontier = PriorityQueue()
    max_frontier = 0

    # List to keep track of optimal path
    path_list = []

    # Necessary statistic for algorithm analysis
        # V: Total # of nodes visited/expanded
        # N: Maxmimum # of nodes stored in memory
        # d: Depth of the optimal solution
        # b: Approximate effective branching factor, N = b^d
    V = 0
    N = 0
    d = 0
    b = 0

    # h(n) = 0
    if heuristic == 0:
        # Algorithm Evaluation Variables
        g_n = 0
        h_n = 0
        f_n = g_n + h_n

        # Create a root node that will be added to the frontier
        root_node = node(f_n, s, None)
        frontier.push(root_node)

        # While the frontier is not empty, keep iterating and generating paths
        while not frontier.isEmpty():
            # Pop the root node off the frontier, and add the initial state to the closed list
            current_node = frontier.pop()
            closed_list.add(current_node.state)

            # GOAL CHECK
            if current_node.state.__str__() == goal_state.__str__():
                # Starting at the goal node, iterate through the parent of each node, and reverse the list to capture the optimal path states
                while current_node:
                    d += 1
                    path_list.append(current_node.state)
                    current_node = current_node.parent
                path_list = path_list[::-1]
                d -= 1

                N = closed_list.length() + frontier.length()
                b = N ** (1 / d)
                print(f"V={V}")
                print(f"N={N}")
                print(f"d={d}")
                print(f"b={b}", '\n')
                for optimal_path in path_list:
                    print(optimal_path)
                return
            
            # Increment g(n) cost by 1, Path Cost = 1
            g_n += 1

            # List of possible puzzle moves
            DIRECTIONS = [
                current_node.state.up(),
                current_node.state.down(),
                current_node.state.left(),
                current_node.state.right()
            ]

            # For every possible move, check if the new state is valid given the state of the current_node
            for successor in DIRECTIONS:
                puzzle_set.add(successor)
                if puzzle_set.isMember(successor):
                    # If the move is valid, increment the # of nodes expanded, calculate the new f(n) value for the state, and create a new node based on the successor state
                    V += 1
                    f_n = g_n + h_n
                    child = node(f_n, successor, current_node)
                    # If the state of the newly created node is NOT in the closed list, add to the frontier
                    if not closed_list.isMember(child.state):
                        frontier.push(child)

    # h(n) = Displaced Tiles
    elif heuristic == 1:
        # Algorithm Evaluation Variables
        g_n = 0
        h_n = s.displaced(goal)
        f_n = g_n + h_n

        # Create a root node that will be added to the frontier
        root_node = node(f_n, s, None)
        frontier.push(root_node)

        # While the frontier is not empty, keep iterating and generating paths
        while not frontier.isEmpty():
            # Pop the root node off the frontier, and add the initial state to the closed list
            current_node = frontier.pop()
            closed_list.add(current_node.state)

            # GOAL CHECK
            if current_node.state.__str__() == goal_state.__str__():
                # Starting at the goal node, iterate through the parent of each node, and reverse the list to capture the optimal path states
                while current_node:
                    d += 1
                    path_list.append(current_node.state)
                    current_node = current_node.parent
                path_list = path_list[::-1]
                d -= 1

                N = closed_list.length() + frontier.length()
                b = N ** (1 / d)
                print(f"V={V}")
                print(f"N={N}")
                print(f"d={d}")
                print(f"b={b}", '\n')
                for optimal_path in path_list:
                    print(optimal_path)
                return
            
            # Increment g(n) cost by 1, Path Cost = 1
            g_n += 1

            # List of possible puzzle moves
            DIRECTIONS = [
                current_node.state.up(),
                current_node.state.down(),
                current_node.state.left(),
                current_node.state.right()
            ]

            # For every possible move, check if the new state is valid given the state of the current_node
            for successor in DIRECTIONS:
                puzzle_set.add(successor)
                if puzzle_set.isMember(successor):
                    # If the move is valid, increment the # of nodes expanded, calculate the new f(n) value for the state, and create a new node based on the successor state
                    V += 1
                    f_n = g_n + current_node.state.displaced(goal)
                    child = node(f_n, successor, current_node)
                    # If the state of the newly created node is NOT in the closed list, add to the frontier
                    if not closed_list.isMember(child.state):
                        frontier.push(child)
    
    # h(n) = Manhattan Distance
    elif heuristic == 2:
        # Algorithm Evaluation Variables
        g_n = 0
        h_n = s.manhattan_dist(goal)
        f_n = g_n + h_n

        # Create a root node that will be added to the frontier
        root_node = node(f_n, s, None)
        frontier.push(root_node)

        # While the frontier is not empty, keep iterating and generating paths
        while not frontier.isEmpty():
            # Pop the root node off the frontier, and add the initial state to the closed list
            current_node = frontier.pop()
            closed_list.add(current_node.state)

            # GOAL CHECK
            if current_node.state.__str__() == goal_state.__str__():
                # Starting at the goal node, iterate through the parent of each node, and reverse the list to capture the optimal path states
                while current_node:
                    d += 1
                    path_list.append(current_node.state)
                    current_node = current_node.parent
                path_list = path_list[::-1]
                d -= 1

                N = closed_list.length() + frontier.length()
                b = N ** (1 / d)
                print(f"V={V}")
                print(f"N={N}")
                print(f"d={d}")
                print(f"b={b}", '\n')
                for optimal_path in path_list:
                    print(optimal_path)
                return
            
            # Increment g(n) cost by 1, Path Cost = 1
            g_n += 1

            # List of possible puzzle moves
            DIRECTIONS = [
                current_node.state.up(),
                current_node.state.down(),
                current_node.state.left(),
                current_node.state.right()
            ]

            # For every possible move, check if the new state is valid given the state of the current_node
            for successor in DIRECTIONS:
                puzzle_set.add(successor)
                if puzzle_set.isMember(successor):
                    # If the move is valid, increment the # of nodes expanded, calculate the new f(n) value for the state, and create a new node based on the successor state
                    V += 1
                    f_n = g_n + current_node.state.manhattan_dist(goal)
                    child = node(f_n, successor, current_node)
                    # If the state of the newly created node is NOT in the closed list, add to the frontier
                    if not closed_list.isMember(child.state):
                        frontier.push(child)
    
    # h(n) = Chebyshev Distance
    elif heuristic == 3:
        # Algorithm Evaluation Variables
        g_n = 0
        h_n = s.chebyshev_dist(goal)
        f_n = g_n + h_n

        # Create a root node that will be added to the frontier
        root_node = node(f_n, s, None)
        frontier.push(root_node)

        # While the frontier is not empty, keep iterating and generating paths
        while not frontier.isEmpty():
            # Pop the root node off the frontier, and add the initial state to the closed list
            current_node = frontier.pop()
            closed_list.add(current_node.state)

            # GOAL CHECK
            if current_node.state.__str__() == goal_state.__str__():
                # Starting at the goal node, iterate through the parent of each node, and reverse the list to capture the optimal path states
                while current_node:
                    d += 1
                    path_list.append(current_node.state)
                    current_node = current_node.parent
                path_list = path_list[::-1]
                d -= 1

                N = closed_list.length() + frontier.length()
                b = N ** (1 / d)
                print(f"V={V}")
                print(f"N={N}")
                print(f"d={d}")
                print(f"b={b}", '\n')
                for optimal_path in path_list:
                    print(optimal_path)
                return
            
            # Increment g(n) cost by 1, Path Cost = 1
            g_n += 1

            # List of possible puzzle moves
            DIRECTIONS = [
                current_node.state.up(),
                current_node.state.down(),
                current_node.state.left(),
                current_node.state.right()
            ]

            # For every possible move, check if the new state is valid given the state of the current_node
            for successor in DIRECTIONS:
                puzzle_set.add(successor)
                if puzzle_set.isMember(successor):
                    # If the move is valid, increment the # of nodes expanded, calculate the new f(n) value for the state, and create a new node based on the successor state
                    V += 1
                    f_n = g_n + current_node.state.chebyshev_dist(goal)
                    child = node(f_n, successor, current_node)
                    # If the state of the newly created node is NOT in the closed list, add to the frontier
                    if not closed_list.isMember(child.state):
                        frontier.push(child)
    
    # Invalid Heuristic Check
    else:
        print('Enter a Valid Heuristic 0 - 3')
        sys.exit(1)

def main():
    inputs = []
    puzzle_list = []
    goal = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
    for input in sys.stdin:
        inputs += input.split()
    for item in inputs:
        puzzle_list.append(int(item))
    puzzle = [puzzle_list[0:3], puzzle_list[3:6], puzzle_list[6:9]]

    heuristic = int(sys.argv[1])

    a_star(puzzle, goal, heuristic)

main()